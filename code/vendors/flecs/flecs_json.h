#define flecs_json_STATIC
#ifndef FLECS_JSON_H
#define FLECS_JSON_H

/* This generated file contains includes for project dependencies */
/*
                                   )
                                  (.)
                                  .|.
                                  | |
                              _.--| |--._
                           .-';  ;`-'& ; `&.
                          \   &  ;    &   &_/
                           |"""---...---"""|
                           \ | | | | | | | /
                            `---.|.|.|.---'

 * This file is generated by bake.lang.c for your convenience. Headers of
 * dependencies will automatically show up in this file. Include bake_config.h
 * in your main project file. Do not edit! */

#ifndef FLECS_JSON_BAKE_CONFIG_H
#define FLECS_JSON_BAKE_CONFIG_H

/* Headers of public dependencies */
#include <flecs.h>
#include <flecs_meta.h>

/* Convenience macro for exporting symbols */
#ifndef flecs_json_STATIC
#if flecs_json_EXPORTS && (defined(_MSC_VER) || defined(__MINGW32__))
  #define FLECS_JSON_API __declspec(dllexport)
#elif flecs_json_EXPORTS
  #define FLECS_JSON_API __attribute__((__visibility__("default")))
#elif defined _MSC_VER
  #define FLECS_JSON_API __declspec(dllimport)
#else
  #define FLECS_JSON_API
#endif
#else
  #define FLECS_JSON_API
#endif

#endif


#ifdef __cplusplus
extern "C" {
#endif

FLECS_JSON_API
char* ecs_ptr_to_json(
    ecs_world_t *world, 
    ecs_entity_t type,
    void *ptr);

FLECS_JSON_API
char* ecs_entity_to_json(
    ecs_world_t *world, 
    ecs_entity_t e,
    ecs_type_t select);

FLECS_JSON_API
char* ecs_iter_to_json(
    ecs_world_t *world, 
    ecs_iter_t *it,
    ecs_iter_next_action_t iter_next,
    ecs_type_t select);

FLECS_JSON_API
char* ecs_type_to_json(
    ecs_world_t *world,
    ecs_type_t type);

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus

namespace flecs {

template <typename T>
std::string to_json(flecs::world& world, flecs::entity_t type, T& data) {
    char *str = ecs_ptr_to_json(world.c_ptr(), type, &data);
    std::string result = std::string(str);
    free(str);
    return result;
}

template <typename T>
std::string to_json(flecs::world& world, flecs::entity type, T& data) {
    return to_json(world, type.id(), data);
}

template <typename T>
std::string to_json(flecs::world& world, T& data) {
    entity_t type = _::component_info<T>::s_entity;
    return flecs::to_json(world, type, data);
}

template <>
inline std::string to_json<flecs::entity>(flecs::world& world, flecs::entity& entity) {
    char *str = ecs_entity_to_json(world.c_ptr(), entity.id(), nullptr);
    std::string result = std::string(str);
    free(str);
    return result;
}

}

#endif

#endif

